<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="介绍本文主要介绍 Scala，一个在 Java 虚拟机上运行的主要语言之一。 我们将从核心语言特性开始，例如值、变量、方法和控制结构。然后，我们将探索一些高级功能，例如高阶函数、柯里化、类、对象和模式匹配。 起步在本教程中，我们将使用来自官网的标准 Scala 安装。 首先，让我们将 scala-library 依赖项添加到我们的 pom.xml 中。 提供了该语言的标准库： 基本特征在本节中，我">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala介绍">
<meta property="og:url" content="http://example.com/2023/01/30/Scala%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="杂货铺">
<meta property="og:description" content="介绍本文主要介绍 Scala，一个在 Java 虚拟机上运行的主要语言之一。 我们将从核心语言特性开始，例如值、变量、方法和控制结构。然后，我们将探索一些高级功能，例如高阶函数、柯里化、类、对象和模式匹配。 起步在本教程中，我们将使用来自官网的标准 Scala 安装。 首先，让我们将 scala-library 依赖项添加到我们的 pom.xml 中。 提供了该语言的标准库： 基本特征在本节中，我">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-30T10:54:13.000Z">
<meta property="article:modified_time" content="2023-01-31T02:52:22.568Z">
<meta property="article:author" content="surzia">
<meta property="article:tag" content="scala">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/01/30/Scala%E4%BB%8B%E7%BB%8D/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Scala介绍 | 杂货铺</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杂货铺</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/30/Scala%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="surzia">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杂货铺">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Scala介绍
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-30 18:54:13" itemprop="dateCreated datePublished" datetime="2023-01-30T18:54:13+08:00">2023-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 10:52:22" itemprop="dateModified" datetime="2023-01-31T10:52:22+08:00">2023-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index"><span itemprop="name">scala</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本文主要介绍 <code>Scala</code>，一个在 <code>Java</code> 虚拟机上运行的主要语言之一。</p>
<p>我们将从核心语言特性开始，例如值、变量、方法和控制结构。然后，我们将探索一些高级功能，例如高阶函数、柯里化、类、对象和模式匹配。</p>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>在本教程中，我们将使用来自<a target="_blank" rel="noopener" href="https://www.scala-lang.org/download/">官网</a>的标准 <code>Scala</code> 安装。</p>
<p>首先，让我们将 <code>scala-library</code> 依赖项添加到我们的 <code>pom.xml</code> 中。 提供了该语言的标准库：</p>
<h1 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h1><p>在本节中，我们将通过示例演示 <code>Scala</code> 基本语法特征。为此，我们将使用 <code>Scala</code> 解释器。</p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>解释器是用于编写程序和表达式的交互式 <code>shell</code>。</p>
<p>首先我们来输出 <code>hello world</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">song@ubuntu20-04:~$ scala</span><br><span class="line">Welcome to Scala 2.11.12 (OpenJDK 64-Bit Server VM, Java 11.0.17).</span><br><span class="line">Type in expressions for evaluation. Or try :help.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span></span><br><span class="line">Hello World!</span><br><span class="line"><span class="meta prompt_">scala&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面，我们通过在命令行中键入<code>scala</code>来启动解释器。解释器启动并显示欢迎消息，然后是提示。</p>
<p>然后，我们在此提示符下键入我们的表达式。解释器读取表达式，对其求值并打印结果。然后，它循环并再次显示提示。</p>
<p>由于它提供即时反馈，因此解释器是开始使用该语言的最简单方法。因此，让我们用它来探索基本的语言特征：表达式和各种定义。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>任何可计算语句都是表达式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">123+321</span></span><br><span class="line">res0: Int = 444</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">7*6</span></span><br><span class="line">res1: Int = 42</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="string">&quot;Hello, &quot;</span>+<span class="string">&quot;Scala&quot;</span></span></span><br><span class="line">res2: String = Hello, Scala</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="string">&quot;scala&quot;</span>*3</span></span><br><span class="line">res3: String = scalascalascala</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">if</span>(11%2==0) <span class="string">&quot;even&quot;</span> <span class="keyword">else</span> <span class="string">&quot;odd&quot;</span></span></span><br><span class="line">res4: String = odd</span><br></pre></td></tr></table></figure>

<p>正如我们在上面看到的，每个表达式都有一个值和一个类型。</p>
<p>如果表达式没有任何返回值，它会返回一个 <code>Unit</code> 类型的值。这种类型只有一个值：()。它类似于 <code>Java</code> 中的 <code>void</code> 关键字。</p>
<h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><p>关键字 <code>val</code> 用于声明常量。</p>
<p>我们用它来命名表达式的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val pi:Double = 3.14</span></span><br><span class="line">pi: Double = 3.14</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="built_in">print</span>(pi)</span></span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>

<p>这样做可以让我们多次重用结果。</p>
<p>常量值是不可变的。因此，我们不能重新分配它们：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">pi = 3.1415</span></span><br><span class="line">&lt;console&gt;:12: error: reassignment to val</span><br><span class="line">       pi = 3.1415</span><br><span class="line">          ^</span><br></pre></td></tr></table></figure>

<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>如果 <code>Scala</code> 需要重新分配一个值，将其声明为变量。</p>
<p>关键字 <code>var</code> 用于声明变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">var radius:Int=3</span></span><br><span class="line">radius: Int = 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">radius=4</span></span><br><span class="line">radius: Int = 4</span><br></pre></td></tr></table></figure>

<h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p><code>Scala</code> 使用 <code>def</code> 关键字定义方法。在关键字之后，指定方法名称、参数声明、分隔符（冒号）和返回类型。在此之后，指定一个分隔符(&#x3D;)，后跟方法主体。</p>
<p>与 <code>Java</code> 相反，<code>Scala</code> 不使用 <code>return</code> 关键字来返回结果。方法返回最后计算的表达式的值。</p>
<p>让我们写一个方法 <code>avg</code> 来计算两个数字的平均值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def avg(x:Double, y:Double):Double = &#123;</span></span><br><span class="line">     | (x + y) / 2</span><br><span class="line">     | &#125;</span><br><span class="line">avg: (x: Double, y: Double)Double</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">avg(10,20)</span></span><br><span class="line">res6: Double = 15.0</span><br></pre></td></tr></table></figure>

<p>如果一个方法不带任何参数，我们可以在定义和调用时省略括号。此外，如果正文只有一个表达式，我们可以省略大括号。</p>
<p>让我们编写一个无参数方法 <code>coinToss</code>，它随机返回“Head”或“Tail”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def coinToss = <span class="keyword">if</span> (Math.random &gt; 0.5) <span class="string">&quot;Head&quot;</span> <span class="keyword">else</span> <span class="string">&quot;Tail&quot;</span></span></span><br><span class="line">coinToss: String</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">println(coinToss)</span></span><br><span class="line">Head</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">println(coinToss)</span></span><br><span class="line">Head</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">println(coinToss)</span></span><br><span class="line">Tail</span><br></pre></td></tr></table></figure>

<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>条件语句允许我们改变程序中的控制流。我们有以下条件语句：</p>
<ul>
<li><code>if-else</code> 表达式</li>
<li><code>while</code> 循环和 <code>do while</code> 循环</li>
<li><code>For</code> 循环</li>
<li><code>Try</code> 语句</li>
<li>匹配表达式</li>
</ul>
<p>与 <code>Java</code> 不同，<code>Scala</code> 没有 <code>continue</code> 或 <code>break</code> 关键字，而有 <code>return</code> 关键字，但是应该避免使用它。</p>
<p><code>Scala</code> 通过匹配表达式进行模式匹配，而不是 <code>switch</code> 语句。</p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a><code>if-else</code></h2><p><code>if-else</code> 表达式类似于 <code>Java``。else</code> 部分是可选的。我们可以嵌套多个 <code>if-else</code> 表达式。</p>
<p>因为它是一个表达式，所以它返回一个值。因此，我们使用它类似于 <code>Java</code> 中的三元运算符 <code>(?:)</code>。事实上，<code>Scala</code> 语言中并没有三元运算符。</p>
<p>使用 <code>if-else</code> 编写一个方法来计算最大公约数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) x <span class="keyword">else</span> gcd(y, x % y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，让我们为这个方法写一个单元测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whenGcdCalledWith15and27_then3</span> </span>= &#123;</span><br><span class="line">  assertEquals(<span class="number">3</span>, gcd(<span class="number">15</span>, <span class="number">27</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><code>while</code> 循环</h2><p><code>while</code> 循环有一个条件和一个主体。当条件为真时，它在循环中重复评估主体——在每次迭代开始时评估条件。</p>
<p>由于它没有任何有用的返回值，因此它返回 <code>Unit</code>。</p>
<p>让我们使用 <code>while</code> 循环编写一个方法来计算最大公约数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcdIter</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> a = x</span><br><span class="line">  <span class="keyword">var</span> b = y</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    a = a % b</span><br><span class="line">    <span class="keyword">val</span> t = a</span><br><span class="line">    a = b</span><br><span class="line">    b = t</span><br><span class="line">  &#125;</span><br><span class="line">  a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Do-while-循环"><a href="#Do-while-循环" class="headerlink" title="Do while 循环"></a><code>Do while</code> 循环</h2><p><code>do while</code> 循环类似于 <code>while</code> 循环，不同之处在于循环条件是在循环结束时计算的。</p>
<p>使用 <code>do-while</code> 循环，让我们编写一个计算阶乘的方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(a: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    result *= i</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (i &lt;= a)</span><br><span class="line">  result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a><code>For</code> 循环</h2><p><code>for</code> 表达式比 <code>Java</code> 中的 <code>for</code> 循环更通用。</p>
<p>它可以迭代单个或多个集合。此外，它可以过滤掉元素并生成新的集合。</p>
<p>使用 <code>for</code> 表达式，让我们编写一个方法来对一系列整数求和：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSum</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i &lt;- a to b) &#123;</span><br><span class="line">    sum += i</span><br><span class="line">  &#125;</span><br><span class="line">  sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>a to b</code> 是生成器表达式。它生成一系列从 <code>a</code> 到 <code>b</code> 的值。</p>
<p><code>i &lt;- a to b</code> 是一个生成器。它将 <code>i</code> 定义为 <code>val</code> 并将生成器表达式生成的一系列值分配给它。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><code>Scala</code> 是一种函数式语言。函数在这里是一等值——我们可以像使用任何其他值类型一样使用它们。</p>
<p>在本节中，我们将研究一些与函数相关的高级概念——局部函数、高阶函数、匿名函数和柯里化。</p>
<h2 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h2><p>我们可以在函数内部定义函数。它们被称为嵌套函数或局部函数。与局部变量类似，它们仅在定义它们的函数内可见。</p>
<p>现在，让我们编写一个使用嵌套函数计算幂的方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span></span>(x: <span class="type">Int</span>, y:<span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">powNested</span></span>(i: <span class="type">Int</span>,</span><br><span class="line">                accumulator: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) accumulator</span><br><span class="line">    <span class="keyword">else</span> powNested(i - <span class="number">1</span>, x * accumulator)</span><br><span class="line">  &#125;</span><br><span class="line">  powNested(y, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>由于函数是值，我们可以将它们作为参数传递给另一个函数。我们也可以让一个函数返回另一个函数。</p>
<p>我们将对函数进行操作的函数称为高阶函数。它们使我们能够在更抽象的层次上工作。使用它们，我们可以通过编写通用算法来减少代码重复。</p>
<p>现在，让我们编写一个高阶函数来对整数范围执行映射和归约操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapReduce</span></span>(r: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>,</span><br><span class="line">              i: <span class="type">Int</span>,</span><br><span class="line">              m: <span class="type">Int</span> =&gt; <span class="type">Int</span>,</span><br><span class="line">              a: <span class="type">Int</span>, b: <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">iter</span></span>(a: <span class="type">Int</span>, result: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">      result</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter(a + <span class="number">1</span>, r(m(a), result))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  iter(a, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>r</code> 和 <code>m</code> 是 <code>Function</code> 类型的参数。通过传递不同的函数，我们可以解决一系列问题，例如平方和或立方之和以及阶乘。</p>
<p>接下来，让我们使用这个函数编写另一个函数 <code>sumSquares</code> 来对整数的平方求和：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whenCalledWithSumAndSquare_thenCorrectValue</span> </span>= &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(x: <span class="type">Int</span>) = x * x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = x + y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sumSquares</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) =</span><br><span class="line">    mapReduce(sum, <span class="number">0</span>, square, a, b)</span><br><span class="line"></span><br><span class="line">  assertEquals(<span class="number">385</span>, sumSquares(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面，我们可以看到高阶函数倾向于创建许多小的一次性函数。我们可以通过使用匿名函数来避免命名它们。</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数是计算结果为函数的表达式。它类似于 <code>Java</code> 中的 <code>lambda</code> 表达式。</p>
<p>让我们使用匿名函数重写前面的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whenCalledWithAnonymousFunctions_thenCorrectValue</span> </span>= &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sumSquares</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) =</span><br><span class="line">    mapReduce((x, y) =&gt; x + y, <span class="number">0</span>, x =&gt; x * x, a, b)</span><br><span class="line">  assertEquals(<span class="number">385</span>, sumSquares(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>mapReduce</code> 接收两个匿名函数：<code>(x, y) =&gt; x + y</code> 和 <code>x =&gt; x * x</code>。</p>
<p><code>Scala</code> 可以从上下文中推导出参数类型。因此，我们省略了这些函数中的参数类型。</p>
<h2 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h2><p>柯里化函数采用多个参数列表，例如 <code>def f(x: Int) (y: Int)</code>。它通过传递多个参数列表来应用，如在 <code>f(5)(6) </code>中。</p>
<p>它被评估为函数链的调用。这些中间函数接受一个参数并返回一个函数。</p>
<p>我们还可以部分指定参数列表，例如 <code>f(5)</code>。</p>
<p>现在，让我们通过一个例子来理解这一点：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whenSumModCalledWith6And10_then10</span> </span>= &#123;</span><br><span class="line">  <span class="comment">// a curried function</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(f : <span class="type">Int</span> =&gt; <span class="type">Int</span>)(a : <span class="type">Int</span>, b : <span class="type">Int</span>) : <span class="type">Int</span> =</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="number">0</span> <span class="keyword">else</span> f(a) + sum(f)(a + <span class="number">1</span>, b)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// another curried function</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mod</span></span>(n : <span class="type">Int</span>)(x : <span class="type">Int</span>) = x % n</span><br><span class="line"></span><br><span class="line">  <span class="comment">// application of a curried function</span></span><br><span class="line">  assertEquals(<span class="number">1</span>, mod(<span class="number">5</span>)(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// partial application of curried function</span></span><br><span class="line">  <span class="comment">// trailing underscore is required to</span></span><br><span class="line">  <span class="comment">// make function type explicit</span></span><br><span class="line">  <span class="keyword">val</span> sumMod5 = sum(mod(<span class="number">5</span>)) _</span><br><span class="line"></span><br><span class="line">  assertEquals(<span class="number">10</span>, sumMod5(<span class="number">6</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面， <code>sum</code> 和 <code>mod</code> 每个都有两个参数列表。<br>我们传递两个参数列表，如 <code>mod(5)(6)</code>。这被评估为两个函数调用。首先，评估 <code>mod(5)</code>，它返回一个函数。反过来，这是用参数 <code>6</code> 调用的。我们得到 <code>1</code> 作为结果。</p>
<p>可以部分应用 <code>mod(5)</code> 中的参数。结果我们得到了一个函数。</p>
<p>同样，在表达式 <code>sum(mod(5)) _</code> 中，我们只将第一个参数传递给 sum 函数。因此，<code>sumMod5</code> 是一个函数。</p>
<p>下划线用作未应用参数的占位符。由于编译器无法推断出预期的函数类型，因此我们使用尾部下划线使函数返回类型明确。</p>
<h2 id="by-name-参数"><a href="#by-name-参数" class="headerlink" title="by-name 参数"></a><code>by-name</code> 参数</h2><p>一个函数可以以两种不同的方式应用参数——按值和按名称——它在调用时只对按值参数求值一次。相反，它会在引用时评估按名称的参数。如果未使用 <code>by-name</code> 参数，则不会对其进行评估。</p>
<p><code>Scala</code> 默认使用按值参数。如果参数类型前面有箭头 <code>(=&gt;)</code>，它会切换到按名称的参数。</p>
<p>现在，让我们用它来实现 <code>while</code> 循环：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whileLoop</span></span>(condition: =&gt; <span class="type">Boolean</span>)(body: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> =</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    body</span><br><span class="line">    whileLoop(condition)(body)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>为了使上述函数正常工作，每次引用参数 <code>condition</code> 和 <code>body</code> 时都应对其进行评估。因此，我们将它们定义为 <code>by-name</code> 参数。</p>
<h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>我们使用 <code>class</code> 关键字定义一个类，后跟类名。</p>
<p>在名称之后，我们可以指定主要的构造函数参数。这样做会自动将具有相同名称的成员添加到类中。</p>
<p>在类主体中，我们定义了成员——值、变量、方法等。默认情况下它们是公共的，除非被私有或受保护的访问修饰符修改。</p>
<p>我们必须使用 <code>override</code> 关键字来覆盖超类中的方法。</p>
<p>让我们定义一个类 Employee：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">val name : <span class="type">String</span>, var salary : <span class="type">Int</span>, annualIncrement : <span class="type">Int</span> = 20</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">incrementSalary</span></span>() : <span class="type">Unit</span> = &#123;</span><br><span class="line">    salary += annualIncrement</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>=</span><br><span class="line">    <span class="string">s&quot;Employee(name=<span class="subst">$name</span>, salary=<span class="subst">$salary</span>)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们指定了三个构造函数参数——<code>name</code>、<code>salary</code> 和 <code>annualIncrement</code>。</p>
<p>由于我们使用 <code>val</code> 和 <code>var</code> 关键字声明 <code>name</code> 和 <code>salary</code>，因此相应的成员是公开的。另一方面，我们没有为 <code>annualIncrement</code> 参数使用 <code>val</code> 或 <code>var</code> 关键字。因此，相应的成员是私有的。由于我们为此参数指定了默认值，因此我们可以在调用构造函数时省略它。</p>
<p>除了字段之外，我们还定义了方法 <code>incrementSalary</code>。这个方法是公开的。</p>
<p>接下来，让我们为这个类写一个单元测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whenSalaryIncremented_thenCorrectSalary</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">val</span> employee = <span class="keyword">new</span> <span class="type">Employee</span>(<span class="string">&quot;John Doe&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">  employee.incrementSalary()</span><br><span class="line">  assertEquals(<span class="number">1020</span>, employee.salary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>我们使用关键字 <code>abstract</code> 来使类抽象。它与 <code>Java</code> 中的类似。它可以拥有普通类可以拥有的所有成员。</p>
<p>此外，它可以包含抽象成员。这些是只有声明而没有定义的成员，它们的定义在子类中提供。</p>
<p>与 <code>Java</code> 类似，我们不能创建抽象类的实例。</p>
<p>现在，让我们用一个例子来说明抽象类。首先，让我们创建一个抽象类 <code>IntSet</code> 来表示整数集：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">  <span class="comment">// add an element to the set</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">incl</span></span>(x: <span class="type">Int</span>): <span class="type">IntSet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// whether an element belongs to the set</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，让我们创建一个具体的子类 <code>EmptyIntSet</code> 来表示空集：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyIntSet</span> <span class="keyword">extends</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x : <span class="type">Int</span>) = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">incl</span></span>(x : <span class="type">Int</span>) =</span><br><span class="line">  <span class="keyword">new</span> <span class="type">NonEmptyIntSet</span>(x, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，另一个子类 <code>NonEmptyIntSet</code> 表示非空集：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonEmptyIntSet</span>(<span class="params">val head : <span class="type">Int</span>, val tail : <span class="type">IntSet</span></span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">IntSet</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x : <span class="type">Int</span>) =</span><br><span class="line">    head == x || (tail contains x)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">incl</span></span>(x : <span class="type">Int</span>) =</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> contains x) &#123;</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">NonEmptyIntSet</span>(x, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，让我们为 <code>NonEmptySet</code> 编写一个单元测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">givenSetOf1To10_whenContains11Called_thenFalse</span> </span>= &#123;</span><br><span class="line">  <span class="comment">// Set up a set containing integers 1 to 10.</span></span><br><span class="line">  <span class="keyword">val</span> set1To10 = <span class="type">Range</span>(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">    .foldLeft(<span class="keyword">new</span> <span class="type">EmptyIntSet</span>() : <span class="type">IntSet</span>) &#123;</span><br><span class="line">        (x, y) =&gt; x incl y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  assertFalse(set1To10 contains <span class="number">11</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h2><p><code>Traits</code> 对应于 <code>Java</code> 接口，但有以下区别：</p>
<ul>
<li>能够从类中扩展</li>
<li>可以访问超类成员</li>
<li>可以有初始化语句</li>
</ul>
<p>我们像定义类一样定义它们，但使用 <code>trait</code> 关键字。此外，除了构造函数参数外，它们可以具有与抽象类相同的成员。此外，它们旨在作为混入添加到其他一些类中。</p>
<p>现在，让我们用一个例子来说明特征。</p>
<p>首先，让我们定义一个 <code>trait UpperCasePrinter</code> 来确保 <code>toString</code> 方法返回一个大写的值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">UpperCasePrinter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>=</span><br><span class="line">    <span class="keyword">super</span>.toString.toUpperCase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，让我们通过将它添加到 <code>Employee</code> 类来测试这个特征：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">givenEmployeeWithTrait_whenToStringCalled_thenUpper</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">val</span> employee = <span class="keyword">new</span> <span class="type">Employee</span>(<span class="string">&quot;John Doe&quot;</span>, <span class="number">10</span>) <span class="keyword">with</span> <span class="type">UpperCasePrinter</span></span><br><span class="line">  assertEquals(<span class="string">&quot;EMPLOYEE(NAME=JOHN DOE, SALARY=10)&quot;</span>, employee.toString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类、对象和特征最多可以继承一个类，但可以继承任意数量的 <code>trait</code>。</p>
<h1 id="对象定义"><a href="#对象定义" class="headerlink" title="对象定义"></a>对象定义</h1><p>对象是类的实例。正如我们在前面的示例中看到的，我们使用 <code>new</code> 关键字从类创建对象。</p>
<p>但是，如果一个类只能有一个实例，我们就需要防止创建多个实例。在 <code>Java</code> 中，我们使用单例模式来实现这一点。</p>
<p>对于这种情况，我们有一种称为对象定义的简洁语法——类似于类定义，但有一点不同。我们不使用 <code>class</code> 关键字，而是使用 <code>object</code> 关键字。这样做定义了一个类并延迟创建它的唯一实例。</p>
<p>我们使用对象定义来实现实用方法和单例。</p>
<p>让我们定义一个 <code>Utils</code> 对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">average</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) =</span><br><span class="line">    (x + y) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们定义了类 <code>Utils</code> 并创建了它的唯一实例。</p>
<p>我们使用它的名称 <code>Utils</code> 来引用这个唯一的实例。该实例是在第一次访问时创建的。</p>
<p>我们不能使用 <code>new</code> 关键字创建另一个 <code>Utils</code> 实例。</p>
<h2 id="伴随对象和伴随类"><a href="#伴随对象和伴随类" class="headerlink" title="伴随对象和伴随类"></a>伴随对象和伴随类</h2><p>如果一个类和一个对象定义有相同的名字，我们分别称它们为伴随类和伴随对象。我们需要在同一个文件中定义两者。伴随对象可以从它们的伴随类访问私有成员，反之亦然。</p>
<p>与 <code>Java</code> 不同，我们没有静态成员。 相反，我们使用伴随对象来实现静态成员。</p>
<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p>模式匹配将一个表达式与一系列备选方案相匹配。其中每一个都以关键字 <code>case</code> 开头。 后面跟着一个模式、分隔箭头 <code>(=&gt;)</code> 和一些表达式。 如果模式匹配，则计算表达式。</p>
<p>我们可以从以下方面构建模式：</p>
<ul>
<li>样例类构造函数</li>
<li>可变模式</li>
<li>通配符模式_</li>
<li>文字</li>
<li>常量标识符</li>
</ul>
<p>样例类使得在对象上进行模式匹配变得容易。我们在定义类时添加 <code>case</code> 关键字，使其成为样例类。</p>
<p>因此，模式匹配比 <code>Java</code> 中的 <code>switch</code> 语句强大得多。因此，它是一种广泛使用的语言功能。</p>
<p>现在，让我们使用模式匹配编写 <code>Fibonacci</code> 方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span></span>(n:<span class="type">Int</span>) : <span class="type">Int</span> = n <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> | <span class="number">1</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="keyword">case</span> x <span class="keyword">if</span> x &gt; <span class="number">1</span> =&gt;</span><br><span class="line">    fibonacci (x<span class="number">-1</span>) + fibonacci(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本教程中，我们介绍了 <code>Scala</code> 语言及其一些主要特性，它为命令式、函数式和面向对象的编程提供了出色的支持。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/scala/" rel="tag"># scala</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2023/01/31/Scala%E4%B8%AD%E7%9A%84Def-Var%E5%92%8CVal/" rel="next" title="Scala中的Def, Var和Val">
      Scala中的Def, Var和Val <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B5%B7%E6%AD%A5"><span class="nav-number">2.</span> <span class="nav-text">起步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">3.</span> <span class="nav-text">基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text">编译器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">3.3.</span> <span class="nav-text">常量定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">3.4.</span> <span class="nav-text">变量定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="nav-number">3.5.</span> <span class="nav-text">方法定义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.</span> <span class="nav-text">条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if-else"><span class="nav-number">4.1.</span> <span class="nav-text">if-else</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.2.</span> <span class="nav-text">while 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Do-while-%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.3.</span> <span class="nav-text">Do while 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#For-%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.4.</span> <span class="nav-text">For 循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">局部函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.</span> <span class="nav-text">柯里化函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#by-name-%E5%8F%82%E6%95%B0"><span class="nav-number">5.5.</span> <span class="nav-text">by-name 参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="nav-number">6.</span> <span class="nav-text">类定义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traits"><span class="nav-number">6.2.</span> <span class="nav-text">Traits</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89"><span class="nav-number">7.</span> <span class="nav-text">对象定义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%B4%E9%9A%8F%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%BC%B4%E9%9A%8F%E7%B1%BB"><span class="nav-number">7.1.</span> <span class="nav-text">伴随对象和伴随类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">8.</span> <span class="nav-text">模式匹配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">9.</span> <span class="nav-text">结论</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="surzia"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">surzia</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/surzia" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;surzia" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">surzia</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
