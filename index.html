<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="杂货铺">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="杂货铺">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="surzia">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>杂货铺</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杂货铺</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/07/Scala%E4%B8%AD%E7%9A%84lazy-val/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="surzia">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/07/Scala%E4%B8%AD%E7%9A%84lazy-val/" class="post-title-link" itemprop="url">Scala中的lazy val</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 22:52:53" itemprop="dateCreated datePublished" datetime="2023-02-07T22:52:53+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-15 22:12:40" itemprop="dateModified" datetime="2023-02-15T22:12:40+08:00">2023-02-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index"><span itemprop="name">scala</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><code>Scala</code> 提供了一个很好的语言特性，称为 <code>lazy val</code>，它可以推迟变量的初始化。惰性初始化模式在 <code>Java</code> 程序中很常见。</p>
<p>虽然看起来很好，但 <code>lazy val</code> 的具体实现存在一些微妙的问题。本文通过分析其底层字节码来检查 <code>lazy val</code> 特性。</p>
<h1 id="Lazy-val是如何工作的？"><a href="#Lazy-val是如何工作的？" class="headerlink" title="Lazy val是如何工作的？"></a><code>Lazy val</code>是如何工作的？</h1><p>要将 <code>val</code> 指定为惰性的，我们只需在变量声明前添加 <code>lazy</code> 关键字：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> foo = &#123;</span><br><span class="line">  println(<span class="string">&quot;Initialized&quot;</span>)</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">foo: <span class="type">Int</span> = &lt;<span class="keyword">lazy</span>&gt;</span><br></pre></td></tr></table></figure>

<p>编译器不会立即评估惰性 <code>val</code> 绑定的表达式。它仅在第一次访问时评估变量。</p>
<p>在初始访问时，编译器计算表达式并将结果存储在惰性 <code>val</code> 中。每当我们在稍后阶段访问此 <code>val</code> 时，都不会执行，编译器会返回结果。</p>
<p>让我们看看运行这个程序时得到的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Initialized</span><br><span class="line">res0: Int = 1</span><br></pre></td></tr></table></figure>

<h1 id="解码-Lazy-val"><a href="#解码-Lazy-val" class="headerlink" title="解码 Lazy val"></a>解码 <code>Lazy val</code></h1><p>接下来，让我们看看 <code>lazy val</code> 内部发生了什么。</p>
<p>首先，我们将在 <code>Person</code> 类中声明一个 <code>lazy val</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> age = <span class="number">27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译 <code>Person.scala</code> 文件时，我们将得到一个 <code>Person.class</code> 文件。我们可以使用任何 <code>java</code> 反编译器反编译此类文件。一旦我们反编译这个类文件，我们就会得到为每个惰性 <code>val</code> 生成的等效 <code>Java</code> 代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> bitmap$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age$lzycompute() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.bitmap$<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.age = <span class="number">27</span>;</span><br><span class="line">                <span class="built_in">this</span>.bitmap$<span class="number">0</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bitmap$<span class="number">0</span> ? <span class="built_in">this</span>.age : <span class="built_in">this</span>.age$lzycompute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 7 行，编译器引入了一个监视器 <code>synchronized (this) &#123;...&#125;</code>。 这保证了变量只初始化一次。 编译器引入了一个 <code>boolean flag bitmap$0</code> 来跟踪初始化状态。当编译器第一次访问 <code>lazy val</code> 时，这个变量会发生变化。</p>
<h1 id="Lazy-val-的性能瓶颈"><a href="#Lazy-val-的性能瓶颈" class="headerlink" title="Lazy val 的性能瓶颈"></a><code>Lazy val</code> 的性能瓶颈</h1><h2 id="访问-Lazy-val-时可能出现死锁"><a href="#访问-Lazy-val-时可能出现死锁" class="headerlink" title="访问 Lazy val 时可能出现死锁"></a>访问 <code>Lazy val</code> 时可能出现死锁</h2><p>当我们从多个线程访问一个实例中的多个 <code>val</code> 时，总是有可能发生死锁：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FirstObj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> initialState = <span class="number">42</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> start = <span class="type">SecondObj</span>.initialState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SecondObj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> initialState = <span class="type">FirstObj</span>.initialState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Deadlock</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="type">Future</span>.sequence(<span class="type">Seq</span>(</span><br><span class="line">      <span class="type">Future</span> &#123;</span><br><span class="line">        <span class="type">FirstObj</span>.start</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="type">Future</span> &#123;</span><br><span class="line">        <span class="type">SecondObj</span>.initialState</span><br><span class="line">      &#125;</span><br><span class="line">    ))</span><br><span class="line">    <span class="type">Await</span>.result(result, <span class="number">10.</span>second)</span><br><span class="line">  &#125;</span><br><span class="line">  run</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行上面的代码时，我们得到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.TimeoutException: Future timed out after [10 seconds]</span><br><span class="line">	at scala.concurrent.impl.Promise$DefaultPromise.tryAwait0(Promise.scala:212)</span><br><span class="line">	at scala.concurrent.impl.Promise$DefaultPromise.result(Promise.scala:225)</span><br><span class="line">	at scala.concurrent.Await$.$anonfun$result$1(package.scala:201)</span><br><span class="line">	at scala.concurrent.BlockContext$DefaultBlockContext$.blockOn(BlockContext.scala:62)</span><br></pre></td></tr></table></figure>

<p>在第 18 行，<code>Future</code> 初始化了 <code>FirstObj</code>，<code>FirstObj</code> 的实例在内部尝试初始化 <code>SecondObj</code>。此外，第 21 行的 <code>Future</code> 尝试初始化 <code>SecondObj</code>，这会导致潜在的死锁情况。</p>
<h2 id="对象内部-Lazy-val-的顺序求值"><a href="#对象内部-Lazy-val-的顺序求值" class="headerlink" title="对象内部 Lazy val 的顺序求值"></a>对象内部 <code>Lazy val</code> 的顺序求值</h2><p>在对象中声明惰性值并尝试并发访问它们。在这种情况下，惰性值会按顺序执行。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LazyValStore</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> squareOf5 = println(square(<span class="number">5</span>))</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> squareOf6 = println(square(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = n * n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SequentialLazyVals</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="type">Future</span>.sequence(<span class="type">Seq</span>(</span><br><span class="line">      <span class="type">Future</span> &#123;</span><br><span class="line">        <span class="type">LazyValStore</span>.squareOf5</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="type">Future</span> &#123;</span><br><span class="line">        <span class="type">LazyValStore</span>.squareOf6</span><br><span class="line">      &#125;</span><br><span class="line">    ))</span><br><span class="line">    <span class="type">Await</span>.result(result, <span class="number">15.</span>second)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器为每个惰性 <code>val</code> 引入了一个监视器。因此，编译器在初始化期间锁定了整个实例。当多个线程尝试访问实例时，线程必须等到所有惰性值都被初始化。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文探讨了 <code>Scala</code> 的 <code>lazy val</code> 的陷阱。可以通过用 <code>lazy val</code> 替换 <code>val</code> 来优化我们的代码。但是，我们必须完全意识到 <code>lazy val</code> 带来的影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/31/Scala%E4%B8%AD%E7%9A%84Def-Var%E5%92%8CVal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="surzia">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/31/Scala%E4%B8%AD%E7%9A%84Def-Var%E5%92%8CVal/" class="post-title-link" itemprop="url">Scala中的Def, Var和Val</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-31 18:20:31 / 修改时间：19:26:07" itemprop="dateCreated datePublished" datetime="2023-01-31T18:20:31+08:00">2023-01-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index"><span itemprop="name">scala</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>本文主要探讨 <code>Scala</code> 中的方法、变量、值和惰性值之间的异同。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法是惰性评估的，这意味着它们的评估会延迟到我们调用它们为止。我们可以通过编写一个将某些内容打印到控制台的方法来检查评估策略：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Methods</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method</span></span>: <span class="type">Int</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;method&quot;</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  println(<span class="string">&quot;After method declaration&quot;</span>)</span><br><span class="line">  println(method)</span><br><span class="line">  println(method)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据控制台输出，我们验证方法在每次调用时都会进行评估：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">After method declaration</span><br><span class="line">method</span><br><span class="line">1</span><br><span class="line">method</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>方法也是不可变的，因此我们不能在创建它们之后更改它们的值。当我们尝试这样做时，编译器将失败并显示 <code>secretNumber_= is not a member of object</code> 消息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secretNumber</span></span>: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line">secretNumber = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="变量（Variables）"><a href="#变量（Variables）" class="headerlink" title="变量（Variables）"></a>变量（Variables）</h1><p>与方法不同，变量会急切求值。他们的评估在声明期间只发生一次：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Variables</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> variable: <span class="type">Int</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;variable&quot;</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  println(<span class="string">&quot;After variable declaration&quot;</span>)</span><br><span class="line">  println(variable)</span><br><span class="line">  println(variable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到变量的评估只发生一次，在声明期间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable</span><br><span class="line">After variable declaration</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>与方法不同，变量是可变的，因为我们可以在创建它们后更改它们的值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> secretNumber: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line">secretNumber = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="常量值（Value）"><a href="#常量值（Value）" class="headerlink" title="常量值（Value）"></a>常量值（Value）</h1><p>与变量类似，值在声明期间发生评估时会被急切评估：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> value: <span class="type">Int</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;value&quot;</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  println(<span class="string">&quot;After value declaration&quot;</span>)</span><br><span class="line">  println(value)</span><br><span class="line">  println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value</span><br><span class="line">After value declaration</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>另一方面，与变量不同，值是不可变的。 当我们尝试分配一个新值时，编译器会失败并显示 <code>reassignment to val</code> 消息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> secretNumber: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line">secretNumber = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="懒惰值（lazy-value）"><a href="#懒惰值（lazy-value）" class="headerlink" title="懒惰值（lazy value）"></a>懒惰值（lazy value）</h1><p>与值不同，它们是惰性求值的，但与方法不同的是，求值只发生一次：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LazyValues</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> lazyValue: <span class="type">Int</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;lazy value&quot;</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  println(<span class="string">&quot;After lazy value declaration&quot;</span>)</span><br><span class="line">  println(lazyValue)</span><br><span class="line">  println(lazyValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到评估发生在第一次使用 <code>lazyValue</code> 期间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">After lazy value declaration</span><br><span class="line">lazy value</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>另一方面，惰性值是不可变的。与值类似，当我们尝试为它们分配新值时，编译器将失败并显示 <code>reassignment to val</code> 消息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> secretNumber: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line">secretNumber = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文介绍了方法、变量、值和惰性值之间的异同。我们专注于他们的评估策略和可变性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/30/Scala%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="surzia">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/30/Scala%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">Scala介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-30 18:54:13" itemprop="dateCreated datePublished" datetime="2023-01-30T18:54:13+08:00">2023-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 10:52:22" itemprop="dateModified" datetime="2023-01-31T10:52:22+08:00">2023-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index"><span itemprop="name">scala</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本文主要介绍 <code>Scala</code>，一个在 <code>Java</code> 虚拟机上运行的主要语言之一。</p>
<p>我们将从核心语言特性开始，例如值、变量、方法和控制结构。然后，我们将探索一些高级功能，例如高阶函数、柯里化、类、对象和模式匹配。</p>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>在本教程中，我们将使用来自<a target="_blank" rel="noopener" href="https://www.scala-lang.org/download/">官网</a>的标准 <code>Scala</code> 安装。</p>
<p>首先，让我们将 <code>scala-library</code> 依赖项添加到我们的 <code>pom.xml</code> 中。 提供了该语言的标准库：</p>
<h1 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h1><p>在本节中，我们将通过示例演示 <code>Scala</code> 基本语法特征。为此，我们将使用 <code>Scala</code> 解释器。</p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>解释器是用于编写程序和表达式的交互式 <code>shell</code>。</p>
<p>首先我们来输出 <code>hello world</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">song@ubuntu20-04:~$ scala</span><br><span class="line">Welcome to Scala 2.11.12 (OpenJDK 64-Bit Server VM, Java 11.0.17).</span><br><span class="line">Type in expressions for evaluation. Or try :help.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span></span><br><span class="line">Hello World!</span><br><span class="line"><span class="meta prompt_">scala&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面，我们通过在命令行中键入<code>scala</code>来启动解释器。解释器启动并显示欢迎消息，然后是提示。</p>
<p>然后，我们在此提示符下键入我们的表达式。解释器读取表达式，对其求值并打印结果。然后，它循环并再次显示提示。</p>
<p>由于它提供即时反馈，因此解释器是开始使用该语言的最简单方法。因此，让我们用它来探索基本的语言特征：表达式和各种定义。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>任何可计算语句都是表达式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">123+321</span></span><br><span class="line">res0: Int = 444</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">7*6</span></span><br><span class="line">res1: Int = 42</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="string">&quot;Hello, &quot;</span>+<span class="string">&quot;Scala&quot;</span></span></span><br><span class="line">res2: String = Hello, Scala</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="string">&quot;scala&quot;</span>*3</span></span><br><span class="line">res3: String = scalascalascala</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="keyword">if</span>(11%2==0) <span class="string">&quot;even&quot;</span> <span class="keyword">else</span> <span class="string">&quot;odd&quot;</span></span></span><br><span class="line">res4: String = odd</span><br></pre></td></tr></table></figure>

<p>正如我们在上面看到的，每个表达式都有一个值和一个类型。</p>
<p>如果表达式没有任何返回值，它会返回一个 <code>Unit</code> 类型的值。这种类型只有一个值：()。它类似于 <code>Java</code> 中的 <code>void</code> 关键字。</p>
<h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><p>关键字 <code>val</code> 用于声明常量。</p>
<p>我们用它来命名表达式的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">val pi:Double = 3.14</span></span><br><span class="line">pi: Double = 3.14</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash"><span class="built_in">print</span>(pi)</span></span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>

<p>这样做可以让我们多次重用结果。</p>
<p>常量值是不可变的。因此，我们不能重新分配它们：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">pi = 3.1415</span></span><br><span class="line">&lt;console&gt;:12: error: reassignment to val</span><br><span class="line">       pi = 3.1415</span><br><span class="line">          ^</span><br></pre></td></tr></table></figure>

<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>如果 <code>Scala</code> 需要重新分配一个值，将其声明为变量。</p>
<p>关键字 <code>var</code> 用于声明变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">var radius:Int=3</span></span><br><span class="line">radius: Int = 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">radius=4</span></span><br><span class="line">radius: Int = 4</span><br></pre></td></tr></table></figure>

<h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p><code>Scala</code> 使用 <code>def</code> 关键字定义方法。在关键字之后，指定方法名称、参数声明、分隔符（冒号）和返回类型。在此之后，指定一个分隔符(&#x3D;)，后跟方法主体。</p>
<p>与 <code>Java</code> 相反，<code>Scala</code> 不使用 <code>return</code> 关键字来返回结果。方法返回最后计算的表达式的值。</p>
<p>让我们写一个方法 <code>avg</code> 来计算两个数字的平均值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def avg(x:Double, y:Double):Double = &#123;</span></span><br><span class="line">     | (x + y) / 2</span><br><span class="line">     | &#125;</span><br><span class="line">avg: (x: Double, y: Double)Double</span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">avg(10,20)</span></span><br><span class="line">res6: Double = 15.0</span><br></pre></td></tr></table></figure>

<p>如果一个方法不带任何参数，我们可以在定义和调用时省略括号。此外，如果正文只有一个表达式，我们可以省略大括号。</p>
<p>让我们编写一个无参数方法 <code>coinToss</code>，它随机返回“Head”或“Tail”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">def coinToss = <span class="keyword">if</span> (Math.random &gt; 0.5) <span class="string">&quot;Head&quot;</span> <span class="keyword">else</span> <span class="string">&quot;Tail&quot;</span></span></span><br><span class="line">coinToss: String</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">println(coinToss)</span></span><br><span class="line">Head</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">println(coinToss)</span></span><br><span class="line">Head</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">scala&gt; </span><span class="language-bash">println(coinToss)</span></span><br><span class="line">Tail</span><br></pre></td></tr></table></figure>

<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>条件语句允许我们改变程序中的控制流。我们有以下条件语句：</p>
<ul>
<li><code>if-else</code> 表达式</li>
<li><code>while</code> 循环和 <code>do while</code> 循环</li>
<li><code>For</code> 循环</li>
<li><code>Try</code> 语句</li>
<li>匹配表达式</li>
</ul>
<p>与 <code>Java</code> 不同，<code>Scala</code> 没有 <code>continue</code> 或 <code>break</code> 关键字，而有 <code>return</code> 关键字，但是应该避免使用它。</p>
<p><code>Scala</code> 通过匹配表达式进行模式匹配，而不是 <code>switch</code> 语句。</p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a><code>if-else</code></h2><p><code>if-else</code> 表达式类似于 <code>Java``。else</code> 部分是可选的。我们可以嵌套多个 <code>if-else</code> 表达式。</p>
<p>因为它是一个表达式，所以它返回一个值。因此，我们使用它类似于 <code>Java</code> 中的三元运算符 <code>(?:)</code>。事实上，<code>Scala</code> 语言中并没有三元运算符。</p>
<p>使用 <code>if-else</code> 编写一个方法来计算最大公约数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) x <span class="keyword">else</span> gcd(y, x % y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，让我们为这个方法写一个单元测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whenGcdCalledWith15and27_then3</span> </span>= &#123;</span><br><span class="line">  assertEquals(<span class="number">3</span>, gcd(<span class="number">15</span>, <span class="number">27</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><code>while</code> 循环</h2><p><code>while</code> 循环有一个条件和一个主体。当条件为真时，它在循环中重复评估主体——在每次迭代开始时评估条件。</p>
<p>由于它没有任何有用的返回值，因此它返回 <code>Unit</code>。</p>
<p>让我们使用 <code>while</code> 循环编写一个方法来计算最大公约数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcdIter</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> a = x</span><br><span class="line">  <span class="keyword">var</span> b = y</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    a = a % b</span><br><span class="line">    <span class="keyword">val</span> t = a</span><br><span class="line">    a = b</span><br><span class="line">    b = t</span><br><span class="line">  &#125;</span><br><span class="line">  a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Do-while-循环"><a href="#Do-while-循环" class="headerlink" title="Do while 循环"></a><code>Do while</code> 循环</h2><p><code>do while</code> 循环类似于 <code>while</code> 循环，不同之处在于循环条件是在循环结束时计算的。</p>
<p>使用 <code>do-while</code> 循环，让我们编写一个计算阶乘的方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(a: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    result *= i</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (i &lt;= a)</span><br><span class="line">  result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a><code>For</code> 循环</h2><p><code>for</code> 表达式比 <code>Java</code> 中的 <code>for</code> 循环更通用。</p>
<p>它可以迭代单个或多个集合。此外，它可以过滤掉元素并生成新的集合。</p>
<p>使用 <code>for</code> 表达式，让我们编写一个方法来对一系列整数求和：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSum</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i &lt;- a to b) &#123;</span><br><span class="line">    sum += i</span><br><span class="line">  &#125;</span><br><span class="line">  sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>a to b</code> 是生成器表达式。它生成一系列从 <code>a</code> 到 <code>b</code> 的值。</p>
<p><code>i &lt;- a to b</code> 是一个生成器。它将 <code>i</code> 定义为 <code>val</code> 并将生成器表达式生成的一系列值分配给它。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><code>Scala</code> 是一种函数式语言。函数在这里是一等值——我们可以像使用任何其他值类型一样使用它们。</p>
<p>在本节中，我们将研究一些与函数相关的高级概念——局部函数、高阶函数、匿名函数和柯里化。</p>
<h2 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h2><p>我们可以在函数内部定义函数。它们被称为嵌套函数或局部函数。与局部变量类似，它们仅在定义它们的函数内可见。</p>
<p>现在，让我们编写一个使用嵌套函数计算幂的方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span></span>(x: <span class="type">Int</span>, y:<span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">powNested</span></span>(i: <span class="type">Int</span>,</span><br><span class="line">                accumulator: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) accumulator</span><br><span class="line">    <span class="keyword">else</span> powNested(i - <span class="number">1</span>, x * accumulator)</span><br><span class="line">  &#125;</span><br><span class="line">  powNested(y, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>由于函数是值，我们可以将它们作为参数传递给另一个函数。我们也可以让一个函数返回另一个函数。</p>
<p>我们将对函数进行操作的函数称为高阶函数。它们使我们能够在更抽象的层次上工作。使用它们，我们可以通过编写通用算法来减少代码重复。</p>
<p>现在，让我们编写一个高阶函数来对整数范围执行映射和归约操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapReduce</span></span>(r: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>,</span><br><span class="line">              i: <span class="type">Int</span>,</span><br><span class="line">              m: <span class="type">Int</span> =&gt; <span class="type">Int</span>,</span><br><span class="line">              a: <span class="type">Int</span>, b: <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">iter</span></span>(a: <span class="type">Int</span>, result: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">      result</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter(a + <span class="number">1</span>, r(m(a), result))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  iter(a, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>r</code> 和 <code>m</code> 是 <code>Function</code> 类型的参数。通过传递不同的函数，我们可以解决一系列问题，例如平方和或立方之和以及阶乘。</p>
<p>接下来，让我们使用这个函数编写另一个函数 <code>sumSquares</code> 来对整数的平方求和：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whenCalledWithSumAndSquare_thenCorrectValue</span> </span>= &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(x: <span class="type">Int</span>) = x * x</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = x + y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sumSquares</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) =</span><br><span class="line">    mapReduce(sum, <span class="number">0</span>, square, a, b)</span><br><span class="line"></span><br><span class="line">  assertEquals(<span class="number">385</span>, sumSquares(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面，我们可以看到高阶函数倾向于创建许多小的一次性函数。我们可以通过使用匿名函数来避免命名它们。</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数是计算结果为函数的表达式。它类似于 <code>Java</code> 中的 <code>lambda</code> 表达式。</p>
<p>让我们使用匿名函数重写前面的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whenCalledWithAnonymousFunctions_thenCorrectValue</span> </span>= &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sumSquares</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) =</span><br><span class="line">    mapReduce((x, y) =&gt; x + y, <span class="number">0</span>, x =&gt; x * x, a, b)</span><br><span class="line">  assertEquals(<span class="number">385</span>, sumSquares(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>mapReduce</code> 接收两个匿名函数：<code>(x, y) =&gt; x + y</code> 和 <code>x =&gt; x * x</code>。</p>
<p><code>Scala</code> 可以从上下文中推导出参数类型。因此，我们省略了这些函数中的参数类型。</p>
<h2 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h2><p>柯里化函数采用多个参数列表，例如 <code>def f(x: Int) (y: Int)</code>。它通过传递多个参数列表来应用，如在 <code>f(5)(6) </code>中。</p>
<p>它被评估为函数链的调用。这些中间函数接受一个参数并返回一个函数。</p>
<p>我们还可以部分指定参数列表，例如 <code>f(5)</code>。</p>
<p>现在，让我们通过一个例子来理解这一点：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whenSumModCalledWith6And10_then10</span> </span>= &#123;</span><br><span class="line">  <span class="comment">// a curried function</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(f : <span class="type">Int</span> =&gt; <span class="type">Int</span>)(a : <span class="type">Int</span>, b : <span class="type">Int</span>) : <span class="type">Int</span> =</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="number">0</span> <span class="keyword">else</span> f(a) + sum(f)(a + <span class="number">1</span>, b)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// another curried function</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mod</span></span>(n : <span class="type">Int</span>)(x : <span class="type">Int</span>) = x % n</span><br><span class="line"></span><br><span class="line">  <span class="comment">// application of a curried function</span></span><br><span class="line">  assertEquals(<span class="number">1</span>, mod(<span class="number">5</span>)(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// partial application of curried function</span></span><br><span class="line">  <span class="comment">// trailing underscore is required to</span></span><br><span class="line">  <span class="comment">// make function type explicit</span></span><br><span class="line">  <span class="keyword">val</span> sumMod5 = sum(mod(<span class="number">5</span>)) _</span><br><span class="line"></span><br><span class="line">  assertEquals(<span class="number">10</span>, sumMod5(<span class="number">6</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面， <code>sum</code> 和 <code>mod</code> 每个都有两个参数列表。<br>我们传递两个参数列表，如 <code>mod(5)(6)</code>。这被评估为两个函数调用。首先，评估 <code>mod(5)</code>，它返回一个函数。反过来，这是用参数 <code>6</code> 调用的。我们得到 <code>1</code> 作为结果。</p>
<p>可以部分应用 <code>mod(5)</code> 中的参数。结果我们得到了一个函数。</p>
<p>同样，在表达式 <code>sum(mod(5)) _</code> 中，我们只将第一个参数传递给 sum 函数。因此，<code>sumMod5</code> 是一个函数。</p>
<p>下划线用作未应用参数的占位符。由于编译器无法推断出预期的函数类型，因此我们使用尾部下划线使函数返回类型明确。</p>
<h2 id="by-name-参数"><a href="#by-name-参数" class="headerlink" title="by-name 参数"></a><code>by-name</code> 参数</h2><p>一个函数可以以两种不同的方式应用参数——按值和按名称——它在调用时只对按值参数求值一次。相反，它会在引用时评估按名称的参数。如果未使用 <code>by-name</code> 参数，则不会对其进行评估。</p>
<p><code>Scala</code> 默认使用按值参数。如果参数类型前面有箭头 <code>(=&gt;)</code>，它会切换到按名称的参数。</p>
<p>现在，让我们用它来实现 <code>while</code> 循环：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whileLoop</span></span>(condition: =&gt; <span class="type">Boolean</span>)(body: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> =</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    body</span><br><span class="line">    whileLoop(condition)(body)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>为了使上述函数正常工作，每次引用参数 <code>condition</code> 和 <code>body</code> 时都应对其进行评估。因此，我们将它们定义为 <code>by-name</code> 参数。</p>
<h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>我们使用 <code>class</code> 关键字定义一个类，后跟类名。</p>
<p>在名称之后，我们可以指定主要的构造函数参数。这样做会自动将具有相同名称的成员添加到类中。</p>
<p>在类主体中，我们定义了成员——值、变量、方法等。默认情况下它们是公共的，除非被私有或受保护的访问修饰符修改。</p>
<p>我们必须使用 <code>override</code> 关键字来覆盖超类中的方法。</p>
<p>让我们定义一个类 Employee：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">val name : <span class="type">String</span>, var salary : <span class="type">Int</span>, annualIncrement : <span class="type">Int</span> = 20</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">incrementSalary</span></span>() : <span class="type">Unit</span> = &#123;</span><br><span class="line">    salary += annualIncrement</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>=</span><br><span class="line">    <span class="string">s&quot;Employee(name=<span class="subst">$name</span>, salary=<span class="subst">$salary</span>)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们指定了三个构造函数参数——<code>name</code>、<code>salary</code> 和 <code>annualIncrement</code>。</p>
<p>由于我们使用 <code>val</code> 和 <code>var</code> 关键字声明 <code>name</code> 和 <code>salary</code>，因此相应的成员是公开的。另一方面，我们没有为 <code>annualIncrement</code> 参数使用 <code>val</code> 或 <code>var</code> 关键字。因此，相应的成员是私有的。由于我们为此参数指定了默认值，因此我们可以在调用构造函数时省略它。</p>
<p>除了字段之外，我们还定义了方法 <code>incrementSalary</code>。这个方法是公开的。</p>
<p>接下来，让我们为这个类写一个单元测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whenSalaryIncremented_thenCorrectSalary</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">val</span> employee = <span class="keyword">new</span> <span class="type">Employee</span>(<span class="string">&quot;John Doe&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">  employee.incrementSalary()</span><br><span class="line">  assertEquals(<span class="number">1020</span>, employee.salary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>我们使用关键字 <code>abstract</code> 来使类抽象。它与 <code>Java</code> 中的类似。它可以拥有普通类可以拥有的所有成员。</p>
<p>此外，它可以包含抽象成员。这些是只有声明而没有定义的成员，它们的定义在子类中提供。</p>
<p>与 <code>Java</code> 类似，我们不能创建抽象类的实例。</p>
<p>现在，让我们用一个例子来说明抽象类。首先，让我们创建一个抽象类 <code>IntSet</code> 来表示整数集：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">  <span class="comment">// add an element to the set</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">incl</span></span>(x: <span class="type">Int</span>): <span class="type">IntSet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// whether an element belongs to the set</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，让我们创建一个具体的子类 <code>EmptyIntSet</code> 来表示空集：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyIntSet</span> <span class="keyword">extends</span> <span class="title">IntSet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x : <span class="type">Int</span>) = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">incl</span></span>(x : <span class="type">Int</span>) =</span><br><span class="line">  <span class="keyword">new</span> <span class="type">NonEmptyIntSet</span>(x, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，另一个子类 <code>NonEmptyIntSet</code> 表示非空集：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonEmptyIntSet</span>(<span class="params">val head : <span class="type">Int</span>, val tail : <span class="type">IntSet</span></span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">IntSet</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x : <span class="type">Int</span>) =</span><br><span class="line">    head == x || (tail contains x)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">incl</span></span>(x : <span class="type">Int</span>) =</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> contains x) &#123;</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">NonEmptyIntSet</span>(x, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，让我们为 <code>NonEmptySet</code> 编写一个单元测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">givenSetOf1To10_whenContains11Called_thenFalse</span> </span>= &#123;</span><br><span class="line">  <span class="comment">// Set up a set containing integers 1 to 10.</span></span><br><span class="line">  <span class="keyword">val</span> set1To10 = <span class="type">Range</span>(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">    .foldLeft(<span class="keyword">new</span> <span class="type">EmptyIntSet</span>() : <span class="type">IntSet</span>) &#123;</span><br><span class="line">        (x, y) =&gt; x incl y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  assertFalse(set1To10 contains <span class="number">11</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h2><p><code>Traits</code> 对应于 <code>Java</code> 接口，但有以下区别：</p>
<ul>
<li>能够从类中扩展</li>
<li>可以访问超类成员</li>
<li>可以有初始化语句</li>
</ul>
<p>我们像定义类一样定义它们，但使用 <code>trait</code> 关键字。此外，除了构造函数参数外，它们可以具有与抽象类相同的成员。此外，它们旨在作为混入添加到其他一些类中。</p>
<p>现在，让我们用一个例子来说明特征。</p>
<p>首先，让我们定义一个 <code>trait UpperCasePrinter</code> 来确保 <code>toString</code> 方法返回一个大写的值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">UpperCasePrinter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>=</span><br><span class="line">    <span class="keyword">super</span>.toString.toUpperCase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，让我们通过将它添加到 <code>Employee</code> 类来测试这个特征：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">givenEmployeeWithTrait_whenToStringCalled_thenUpper</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">val</span> employee = <span class="keyword">new</span> <span class="type">Employee</span>(<span class="string">&quot;John Doe&quot;</span>, <span class="number">10</span>) <span class="keyword">with</span> <span class="type">UpperCasePrinter</span></span><br><span class="line">  assertEquals(<span class="string">&quot;EMPLOYEE(NAME=JOHN DOE, SALARY=10)&quot;</span>, employee.toString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类、对象和特征最多可以继承一个类，但可以继承任意数量的 <code>trait</code>。</p>
<h1 id="对象定义"><a href="#对象定义" class="headerlink" title="对象定义"></a>对象定义</h1><p>对象是类的实例。正如我们在前面的示例中看到的，我们使用 <code>new</code> 关键字从类创建对象。</p>
<p>但是，如果一个类只能有一个实例，我们就需要防止创建多个实例。在 <code>Java</code> 中，我们使用单例模式来实现这一点。</p>
<p>对于这种情况，我们有一种称为对象定义的简洁语法——类似于类定义，但有一点不同。我们不使用 <code>class</code> 关键字，而是使用 <code>object</code> 关键字。这样做定义了一个类并延迟创建它的唯一实例。</p>
<p>我们使用对象定义来实现实用方法和单例。</p>
<p>让我们定义一个 <code>Utils</code> 对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">average</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) =</span><br><span class="line">    (x + y) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们定义了类 <code>Utils</code> 并创建了它的唯一实例。</p>
<p>我们使用它的名称 <code>Utils</code> 来引用这个唯一的实例。该实例是在第一次访问时创建的。</p>
<p>我们不能使用 <code>new</code> 关键字创建另一个 <code>Utils</code> 实例。</p>
<h2 id="伴随对象和伴随类"><a href="#伴随对象和伴随类" class="headerlink" title="伴随对象和伴随类"></a>伴随对象和伴随类</h2><p>如果一个类和一个对象定义有相同的名字，我们分别称它们为伴随类和伴随对象。我们需要在同一个文件中定义两者。伴随对象可以从它们的伴随类访问私有成员，反之亦然。</p>
<p>与 <code>Java</code> 不同，我们没有静态成员。 相反，我们使用伴随对象来实现静态成员。</p>
<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p>模式匹配将一个表达式与一系列备选方案相匹配。其中每一个都以关键字 <code>case</code> 开头。 后面跟着一个模式、分隔箭头 <code>(=&gt;)</code> 和一些表达式。 如果模式匹配，则计算表达式。</p>
<p>我们可以从以下方面构建模式：</p>
<ul>
<li>样例类构造函数</li>
<li>可变模式</li>
<li>通配符模式_</li>
<li>文字</li>
<li>常量标识符</li>
</ul>
<p>样例类使得在对象上进行模式匹配变得容易。我们在定义类时添加 <code>case</code> 关键字，使其成为样例类。</p>
<p>因此，模式匹配比 <code>Java</code> 中的 <code>switch</code> 语句强大得多。因此，它是一种广泛使用的语言功能。</p>
<p>现在，让我们使用模式匹配编写 <code>Fibonacci</code> 方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span></span>(n:<span class="type">Int</span>) : <span class="type">Int</span> = n <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> | <span class="number">1</span> =&gt; <span class="number">1</span></span><br><span class="line">  <span class="keyword">case</span> x <span class="keyword">if</span> x &gt; <span class="number">1</span> =&gt;</span><br><span class="line">    fibonacci (x<span class="number">-1</span>) + fibonacci(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本教程中，我们介绍了 <code>Scala</code> 语言及其一些主要特性，它为命令式、函数式和面向对象的编程提供了出色的支持。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="surzia"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">surzia</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/surzia" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;surzia" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">surzia</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
